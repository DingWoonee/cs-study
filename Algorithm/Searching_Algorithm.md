# 탐색 알고리즘
## 1 탐색의 기본 개념
### 1.1 탐색이란?
> 탐색(Search)이란 데이터 집합에서 원하는 값을 찾는 과정이다.  
> 즉, **key(찾고자 하는 값)와 data structure(찾을 대상이 저장된 구조)가 존재**하고,  
> 알고리즘은 이 key를 해당 집합 안에서 얼마나 효율적으로 찾는지를 결정한다.

### 1.2 탐색 알고리즘을 평가하는 주요 기준
- **시간 복잡도(Time Complexity)**  
  → 얼마나 빨리 찾는가?
- **공간 복잡도(Space Complexity)**  
  → 얼마나 추가 메모리를 쓰는가?
- **정렬 필요 여부(Sorted Requirement)**  
  → 탐색 전에 정렬이 필요한가?  
  (이진 탐색은 매우 빠른 탐색 알고리즘이지만, 정렬된 상태에서만 사용 가능하다.)
- **데이터 구조 집중(Structure Dependency)**  
  → 데이터가 어떤 구조에 저장되어 있는지에 따라 성능이 크게 달라진다.

## 2 기본 탐색 알고리즘
### 2.1 선형 탐색(Linear Search)
> 배열/리스트의 **처음부터 끝까지 순서대로** 보면서 **하나씩 비교**하는 방식

가장 직관적이다.  
데이터가 많은 경우는 성능이 매우 안 좋다.

- **시간 복잡도**  
  최악/평균: `O(N)`  
  최선: `O(1)`

- **조건 정리**  
  순차 접근이 가능한 자료구조

### 2.2 이진 탐색 (Binary Search)
> **정렬된 배열**에 대해 사용할 수 있는 매우 강력한 탐색 수단  
> 가운데 원소를 골라서 범위를 절반씩 줄인다.

**인덱스로 접근이 가능**한 배열이나 리스트여야 한다.  

`while`문을 돌면서 반복문으로 구현할 수 있고,  
범위를 함수의 파라미터로 넘겨서 재귀적으로도 구현할 수 있다.

- **시간 복잡도**  
  최악/평균/최선: `O(log N)`  
  각 단계마다 절반씩 줄고, 구간의 길이가 1이 될 때까지 줄이기 때문이다.

- **조건 정리**  
  정렬 필요 / 랜덤 접근 가능한 자료구조

## 3 트리 기반 탐색
- **트리 자료구조를 사용하는 이유**  
  삽입/삭제가 효율적이고 검색과 정렬을 효율적으로 수행할 수 있다.

### 3.1 이진 탐색 트리(BST: Binary Search Tree)
> 아래의 특징을 가진 이진 트리를 **이진 탐색 트리**라고 한다.  
> 
> 임의의 노드 X에 대해
> - 왼쪽 서브트리: X보다 작은 값들
> - 오른쪽 서브트리: X보다 큰 값들

- **탐색(Search) 과정**  
  1. 루트(root)에서 시작
  2. 현재 노드 값 `v`와 찾는 값(`key`)을 비교
     - `key == v` → 찾음
     - `key < v` → 왼쪽 자식으로 이동
     - `key > v` → 오른쪽 자식으로 이동
  3. 리프 노드에 도달했는데도 없으면 → 트리에 없음  

  ⇒ 이진 탐색과 로직이 유사한데, 비교 대상이 '중간 인덱스'가 아니라 '현재 노드'이다.

- **삽입(Insert)**  
  1. 탐색하듯이 내려가면서
     - `key < v` → 왼쪽으로
     - `key > v` → 오른쪽으로
  2. 더 내려갈 자식이 없으면 → 그 위치에 새 노드 삽입

- **삭제(Delete)**  
  일단 탐색해서 대상 노드를 찾는다.
  1. 자식이 없는 경우 → 그냥 떼어낸다.
  2. 자식이 하나인 경우 → 그 자식을 부모에게 붙여주고 본인을 제거한다.
  3. 자식이 두 개인 경우 → 오른쪽 서브트리에서 "가장 작은 값" 또는 왼쪽 서브트리에서 "가장 큰 값"을 가져와서 현재 노드 자리에 위치시킨다.

- **시간 복잡도**  
  BST에서 **탐색 / 삽입 / 삭제는 모두**  
  **`O(h)`의 시간 복잡도**를 가진다.  

  **트리의 균형**에 따라 이 높이가 달라지고, 시간 복잡도가 달라진다.  
  ⇒ 그래서 **균형**이 중요하다.  
  (삽입 순서에 따라 한쪽으로 쏠리는 "사다리 모양"될 수도 있다.)  
  ⇒ 그래서 나온 것이 **균형 이진 트리**이고, 대표적인 것이 아래의 AVL Tree와 Red-Black Tree이다.

### 3.2 AVL Tree / Red-Black Tree

## 4 그래프 탐색
### 4.1 기본 용어
| 개념           | 의미                     |
| ------------ | ---------------------- |
| 정점(Vertex)   | 노드(Node)               |
| 간선(Edge)     | 정점과 정점을 잇는 연결선         |
| 인접(Adjacent) | 서로 연결된 상태              |
| 가중치(Weight)  | 간선의 비용(weight), 길이, 시간 |
| 사이클(Cycle)   | 시작 정점으로 돌아올 수 있는 경로 존재 |

### 4.2 BFS(Breadth-First Search)
> 가까운 정점부터 **레벨 단위로 확장**하며 탐색하는 기법

- **구현 필요 요소**  
  1. visited 배열
  2. Queue

- **시간 복잡도**  
  모든 정점을 한 번씩 + 모든 정점과 연결된 모든 간선을 한 번씩  
  → `O(V + E)`  

- **강점**  
  - 최단 거리 (가중치가 모두 동일할 경우)
  - 미로
  - 불/바이러스 확산/전염
  - 레벨 기반 탐색

### 4.3 DFS(Depth-First Search)
> 한 방향으로 끝까지 들어가며 탐색하고, 막히면 되돌아오면서 탐색하는 기법

- **구현 필요 요소**  
  1. visited 배열
  2. 재귀 함수 or Stack

- **시간 복잡도**  
  모든 정점을 한 번씩 + 모든 정점과 연결된 모든 간선을 한 번씩  
  → `O(V + E)` 

- **강점**  
  - 모든 경로 탐색 / 경로 종류
  - 백트래킹
  - 분기한정 (가지치기)

## 5 해시 기반 탐색
### 5.1 Hash Table 구조
> Key를 해시 함수에 넣어서 나온 Value를 통해 값에 바로 접근하는 자료구조

⇒ 인덱스로 `O(1)`에 접근 + 임의의 키(문자열, 객체 등) 사용 가능

- **Hash Table의 요소**  
  1. 버킷 배열
  2. 해시 함수
  3. 충돌 해결 전략

### 5.2 충돌 해결 방식

### 5.3 평균 `O(1)` 탐색의 의미

## 6 고급 탐색 기법
### 6.1  이진 탐색 응용

### 6.2 분할 정복 기반 탐색

### 6.3 Ternary Search (삼분 탐색)
