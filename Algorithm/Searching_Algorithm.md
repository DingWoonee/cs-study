# 탐색 알고리즘
## 1 탐색의 기본 개념
### 1.1 탐색이란?
> 탐색(Search)이란 데이터 집합에서 원하는 값을 찾는 과정이다.  
> 즉, **key(찾고자 하는 값)와 data structure(찾을 대상이 저장된 구조)가 존재**하고,  
> 알고리즘은 이 key를 해당 집합 안에서 얼마나 효율적으로 찾는지를 결정한다.

### 1.2 탐색 알고리즘을 평가하는 주요 기준
- **시간 복잡도(Time Complexity)**  
  → 얼마나 빨리 찾는가?
- **공간 복잡도(Space Complexity)**  
  → 얼마나 추가 메모리를 쓰는가?
- **정렬 필요 여부(Sorted Requirement)**  
  → 탐색 전에 정렬이 필요한가?  
  (이진 탐색은 매우 빠른 탐색 알고리즘이지만, 정렬된 상태에서만 사용 가능하다.)
- **데이터 구조 집중(Structure Dependency)**  
  → 데이터가 어떤 구조에 저장되어 있는지에 따라 성능이 크게 달라진다.

## 2 기본 탐색 알고리즘
### 2.1 선형 탐색(Linear Search)
> 배열/리스트의 **처음부터 끝까지 순서대로** 보면서 **하나씩 비교**하는 방식

가장 직관적이다.  
데이터가 많은 경우는 성능이 매우 안 좋다.

- **시간 복잡도**  
  최악/평균: `O(N)`  
  최선: `O(1)`

- **조건 정리**  
  순차 접근이 가능한 자료구조

### 2.2 이진 탐색 (Binary Search)
> **정렬된 배열**에 대해 사용할 수 있는 매우 강력한 탐색 수단  
> 가운데 원소를 골라서 범위를 절반씩 줄인다.

**인덱스로 접근이 가능**한 배열이나 리스트여야 한다.  

`while`문을 돌면서 반복문으로 구현할 수 있고,  
범위를 함수의 파라미터로 넘겨서 재귀적으로도 구현할 수 있다.

- **시간 복잡도**  
  최악/평균/최선: `O(log N)`  
  각 단계마다 절반씩 줄고, 구간의 길이가 1이 될 때까지 줄이기 때문이다.

- **조건 정리**  
  정렬 필요 / 랜덤 접근 가능한 자료구조

## 3 트리 기반 탐색
- **트리 자료구조를 사용하는 이유**  
  삽입/삭제가 효율적이고 검색과 정렬을 효율적으로 수행할 수 있다.

### 3.1 이진 탐색 트리(BST: Binary Search Tree)
> 아래의 특징을 가진 이진 트리를 **이진 탐색 트리**라고 한다.  
> 
> 임의의 노드 X에 대해
> - 왼쪽 서브트리: X보다 작은 값들
> - 오른쪽 서브트리: X보다 큰 값들

- **탐색(Search) 과정**  
  1. 루트(root)에서 시작
  2. 현재 노드 값 `v`와 찾는 값(`key`)을 비교
     - `key == v` → 찾음
     - `key < v` → 왼쪽 자식으로 이동
     - `key > v` → 오른쪽 자식으로 이동
  3. 리프 노드에 도달했는데도 없으면 → 트리에 없음  

  ⇒ 이진 탐색과 로직이 유사한데, 비교 대상이 '중간 인덱스'가 아니라 '현재 노드'이다.

- **삽입(Insert)**  
  1. 탐색하듯이 내려가면서
     - `key < v` → 왼쪽으로
     - `key > v` → 오른쪽으로
  2. 더 내려갈 자식이 없으면 → 그 위치에 새 노드 삽입

- **삭제(Delete)**  
  일단 탐색해서 대상 노드를 찾는다.
  1. 자식이 없는 경우 → 그냥 떼어낸다.
  2. 자식이 하나인 경우 → 그 자식을 부모에게 붙여주고 본인을 제거한다.
  3. 자식이 두 개인 경우 → 오른쪽 서브트리에서 "가장 작은 값" 또는 왼쪽 서브트리에서 "가장 큰 값"을 가져와서 현재 노드 자리에 위치시킨다.

- **시간 복잡도**  
  BST에서 **탐색 / 삽입 / 삭제는 모두**  
  **`O(h)`의 시간 복잡도**를 가진다.  

  **트리의 균형**에 따라 이 높이가 달라지고, 시간 복잡도가 달라진다.  
  ⇒ 그래서 **균형**이 중요하다.  
  (삽입 순서에 따라 한쪽으로 쏠리는 "사다리 모양"될 수도 있다.)  
  ⇒ 그래서 나온 것이 **균형 이진 트리**이고, 대표적인 것이 아래의 AVL Tree와 Red-Black Tree이다.

### 3.2 AVL Tree / Red-Black Tree

## 4 그래프 탐색
### 4.1 기본 용어
| 개념           | 의미                     |
| ------------ | ---------------------- |
| 정점(Vertex)   | 노드(Node)               |
| 간선(Edge)     | 정점과 정점을 잇는 연결선         |
| 인접(Adjacent) | 서로 연결된 상태              |
| 가중치(Weight)  | 간선의 비용(weight), 길이, 시간 |
| 사이클(Cycle)   | 시작 정점으로 돌아올 수 있는 경로 존재 |

### 4.2 BFS(Breadth-First Search)
> 가까운 정점부터 **레벨 단위로 확장**하며 탐색하는 기법

- **구현 필요 요소**  
  1. visited 배열
  2. Queue

- **시간 복잡도**  
  모든 정점을 한 번씩 + 모든 정점과 연결된 모든 간선을 한 번씩  
  → `O(V + E)`  

- **강점**  
  - 최단 거리 (가중치가 모두 동일할 경우)
  - 미로
  - 불/바이러스 확산/전염
  - 레벨 기반 탐색

### 4.3 DFS(Depth-First Search)
> 한 방향으로 끝까지 들어가며 탐색하고, 막히면 되돌아오면서 탐색하는 기법

- **구현 필요 요소**  
  1. visited 배열
  2. 재귀 함수 or Stack

- **시간 복잡도**  
  모든 정점을 한 번씩 + 모든 정점과 연결된 모든 간선을 한 번씩  
  → `O(V + E)` 

- **강점**  
  - 모든 경로 탐색 / 경로 종류
  - 백트래킹
  - 분기한정 (가지치기)

## 5 해시 기반 탐색
### 5.1 Hash Table 구조
> Key를 해시 함수에 넣어서 나온 Value를 통해 값에 바로 접근하는 자료구조

⇒ 인덱스로 `O(1)`에 접근 + 임의의 키(문자열, 객체 등) 사용 가능

- **Hash Table의 요소**  
  1. 버킷 배열 → 데이터 저장
  2. 해시 함수 → Key를 정수값으로 매핑
  3. 충돌 해결 전략

### 5.2 충돌(Collision)
- **좋은 해시 함수**  
  - 같은 key는 항상 같은 hash 값을 반환한다.
  - 다른 key는 가능한 서로 다른 hash 값을 반환한다.
  - 특정 값에 편향되지 않도록 **균등 분포**를 이루는 것이 좋다.

- **충돌(Collision)**  
  해시 함수는 유한한 범위의 인덱스만 만들 수 있다.  
  → 하지만 Key는 사실상 무한대이고  
  → **비둘기집 원리**로 서로 다른 Key가 같은 index로 가는 것은 피할 수 없다.  
  ⇒ 이것이 **충돌**이고, 이를 해결하는 방식에는 여러가지가 있다.

### 5.3 충돌 해결 방식 1 - Open Addressing(개방 주소법)
> 충돌이 나면, **같은 배열 안에서 다른 빈 칸을 찾아서 저장**하는 방식

- **장점**  
  구조가 단순하다. (배열만 있으면 됨)  

  캐시 친화적이다. (배열임)
  
- **단점**  
  Load Factor(채워진 비율)가 높아질수록 성능이 급격히 저하된다.  
  (그리고 Load Factor가 1을 넘을 수 없다.)  
  
  삭제 처리가 복잡하다. (탐색 경로 유지 문제)

1. **Linear Probing(선형 탐사)**  
   이미 해시 값에 해당하는 index가 차있다면, **다음 칸(index + 1)에 저장**한다.  

   클러스터링이 발생 가능하고, 연속해서 차 있을 경우 탐색 길이가 길어질 수 있다.

2. **Quadratic Probing(제곱 탐사)**  
   빈 칸이 나올 때까지 index를 +1씩 하는 것이 아니라 제곱 씩 더한다.
   → index + 1^2 → index + 2^2 → index + 3^2 → ...  

   단순 선형보다 클러스터링을 줄이려는 방법이다.

3. **Double Hashing(이중 해싱)**  
   해시 함수를 하나 더 도입해서 이동 간격을 정하는 방식이다.
   ```
   index = h1(key)
   step = h2(key)
  
   충돌 시:
   index = (index + step) % M
   ```

### 5.4 충돌 해결 방식 2 - Chaining
> 충돌이 나면, **그 인덱스에 "연결 리스트(또는 다른 구조)를 연결"** 해서  
> 여러 개를 저장하는 방식

해시 테이블의 각 인덱스에는 리스트나 트리/버킷 등의 구조가 들어가 있다.  
→ 충돌 시 이 구조에 같이 저장한다.

- **장점**  
  Load Factor가 1보다 커도 저장이 가능하다. (성능도 상대적으로 괜찮음)  
  삭제가 간단한다.  
  구현이 유연하다.

- **단점**  
  캐시 지역성이 떨어진다. (추가적인 자료구조 사용하기 때문)  
  포인터를 사용한다. (이게 오버헤드임)

## 6 고급 탐색 기법
### 6.1  이진 탐색 응용

### 6.2 분할 정복 기반 탐색

### 6.3 Ternary Search (삼분 탐색)
