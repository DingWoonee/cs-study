# 선형 자료구조(Linear Data Structure)
### 📚 목차
- [1 선형 자료구조 개요](#1-선형-자료구조-개요)
- [2 배열(Array)](#2-배열array)
- [3 연결 리스트(Linked List)](#3-연결-리스트linked-list)
- [4 스택(Stack)](#4-스택stack)
- [5 큐(Queue)](#5-큐queue)
- [6 덱(Deque: Double-ended Queue)](#6-덱deque-double-ended-queue)

## 1 선형 자료구조 개요
### 1.1 선형 vs 비선형 자료구조
- **선형 자료구조(Linear Data Structure)**  
  > 데이터가 **일렬로 순서 있게 나열된 구조**이다.  
  > → 1대1 관계

  - 연속적(배열) 또는 포인터 기반 연결 리스트 구조이다.
  - 순차 접근이 기본이다.

- **비선형 자료구조(Non-linear Data Structure)**  
  > 데이터가 **계층적이거나 망처럼 연결된 구조**이다.  
  > → **1대N 또는 N대N 관계**

  - 노드 간 링크(포인터)로 연결된다.
  - 게층적이거나 임의 접근한다.

### 1.2 메모리 배치 (연속/비연속)
선형 자료구조는 **메모리에 어떻게 배치하느냐**에 따라 성질이 달라진다.

- **연속 메모리(Contiguous Memory)**  
  > Array, ArrayList 계열

  - **특징**
    - 요소들이 **연속된 메모리 공간에 저장**된다.
    - 주소에 offset을 더해서 주소를 계산해서 `O(1)`으로 바로 접근 가능한다.(Random Access)
    - CPU 캐시 입장에서 **캐시 친화적**이다. → 순회가 빠르다.
      
  - **장점**  
    인덱스 접근이 매우 빠르고(Random Access), 구현이 단순하다.

  - **단점**  
    중간에 삽입/삭제하면 뒤의 것이 메모리 상 위치를 다 변경시켜줘야 됨.  
    → 삽입/삭제: `O(n)`  

- **비연속 메모리(Non-Contiguous Memory)**  
  > Linked List 계열

  - **특징**  
    - 각 노드는 메모리에서 연속되지 않고 흩어져 있다.
    - 각 노드는 **포인터로 연결**된다.
    - 포인트를 따라가야 해서 특정 인덱스로 바로 접근이 불가능하다.

  - **장점**  
    중간 삽입/삭제가 `O(1)`이다. (탐색은 별도)  
    처음 크기를 크게 잡지 않아도 된다.

  - **단점**  
    포인터를 위한 메모리 필요  
    **캐시 효율이 떨어진다.**  
    삽입/삭제는 빨라도, 삽입/삭제할 노드를 찾는 과정은 `O(n)`이다.

### 1.3 인터페이스(추상 자료형, ADT) 개념
> ADT(Abstract Data Type, 추상 자료형)은  
> "**어떤 자료구조가 어떤 연산을 제공해야 하는지를 추상적으로 정의한 것**"이다.

→ 자바에서 `List` 인터페이스가 ADT이고, `ArrayList`나 `LinkedList`가 그 ADT의 구현체이다.

## 2 배열(Array)
> 배열(Array)은 **동일한 자료형의 데이터가 연속된 메모리에 저장된 선형 자료구조**이다.

### 2.1 특징
- 접근 시 Random Access(임의 접근)으로, `O(1)`이다.
- 저장 데이터의 개수와 타입이 고정적이다.
- 캐시 효율이 좋다.
- 삽입/삭제에 `O(n)`이 걸린다.  
  
⇒ 읽기 매우 빠름, 중간 삽입/삭제 느림.

### 2.2 메모리 구조
배열은 **연속된 메모리 공간에 고정 크기**로 잡힌다.  
→ 선언 시 크기가 결정된다.

⇒ 배열은 "**빠른 탐색**"을 위해 만들어진 자료구조 이다.

### 2.3 삽입/삭제 성능 분석
| 위치        | 연산 비용 | 이유          |
| --------- | ----- | ----------- |
| 맨 앞 삽입/삭제 | O(n)  | 전체를 한 칸씩 이동 |
| 중간 삽입/삭제  | O(n)  | 삽입 지점 이후 복사 |
| 맨 뒤 삽입    | O(1)  | 공간만 있다면 빠름  |

### 2.4 동적 배열(ArrayList)과 크기 확장 전략
자바의 `ArrayList`는 **동적 배열**을 사용한다.  
→ 공간이 부족하면 **더 큰 크기의 배열을 새로 할당**.  
→ **기존 요소를 복사**하고 참조를 변경.

- **시작 복잡도**  
  뒤에 원소를 추가하는 경우  
  | 상황                  | 시간 복잡도               | 이유                |
  | ------------------- | -------------------- | ----------------- |
  | **빈 칸이 있음**         | **O(1)** (암묵적 상수 시간) | 단순히 마지막 인덱스에 저장   |
  | **빈 칸이 없음 (용량 부족)** | **O(n)**             | 더 큰 배열로 복사(확장) 필요 |

  중간에 삽입/삭제  
  | 연산                  | 시간 복잡도   | 이유                  |
  | ------------------- | -------- | ------------------- |
  | **중간 삽입 add(i, x)** | **O(n)** | 이후 요소들을 전부 뒤로 밀어야 함 |
  | **중간 삭제 remove(i)** | **O(n)** | 이후 요소들을 앞으로 당겨야 함   |

## 3 연결 리스트(Linked List)
> 연결 리스트는 **노드(Node)들이 포인터로 서로 연결**된 자료구조이다.

### 3.1 특징
- 메모리가 **비연속적**이고, **포인터로 연결**되어 있다.
- 삽입/삭제 시 노드 `O(1)`이다.
- 탐색 시 `O(n)`이다.
- 각 노드에 데이터 외에 **포인터 저장으로 인한 오버헤드**가 존재한다.

⇒ 중간 삽입/삭제는 빠름, 탐색은 느림
  
### 3.2 단일/이중/원형 연결 리스트
| 구조           | 설명               | 장점           | 단점                |
| ------------ | ---------------- | ------------ | ----------------- |
| 단일(Singly)   | A → B → C        | 구현 간단        | 역방향 탐색 불가         |
| 이중(Doubly)   | A ⇄ B ⇄ C        | 양방향 탐색       | 포인터 2개 → 메모리 더 사용 |
| 원형(Circular) | 마지막 노드 → 첫 노드 연결 | 헤드 없이도 순환 가능 | 종료 조건 필요          |

### 3.3 Node 구조체
- **단일 리스트**
  ```java
  class Node {
      int data;
      Node next;
  }
  ```
- **이중 리스트**
  ```java
  class Node {
      int data;
      Node prev;
      Node next;
  }
  ```

### 3.4 실제 사용시 주의점
| 항목              | 설명                          |
| --------------- | --------------------------- |
| 캐시 비친화적         | 데이터가 흩어져 있어 순차 접근도 느릴 수 있음  |
| 삽입/삭제도 O(1)은 아님 | **위치를 찾는 탐색**이 먼저 필요 → O(n) |
| 메모리 오버헤드        | 포인터 저장 때문에 메모리 2배 가까이 사용    |
| GC 객체 증가        | 자바/Python에서는 성능에 악영향        |

⇒ 실무에서 연결 리스트를 직접 쓰는 경우는 거의 없다.  
⇒ 대부분 `ArrayList`나 `ArrayDeque` 등으로 충분하다.

## 4 스택(Stack)
> 스택은 **LIFO(Last In, First Out: 후입선출)** 방식의 선형 자료구조이다.  
> → 마지막에 들어온 데이터가 가장 먼저 나간다.

### 4.1 주요 연산
| 연산          | 설명                 | 시간복잡도 |
| ----------- | ------------------ | ----- |
| `push(x)`   | 스택 맨 위(Top)에 요소 추가 | O(1)  |
| `pop()`     | Top 요소 제거 및 반환     | O(1)  |
| `peek()`    | Top 요소 확인          | O(1)  |
| `isEmpty()` | 비어 있는지 확인          | O(1)  |

⇒ 스택은 **항상 Top을 기준**으로 모든 작업이 이루어진다.

### 4.2 배열 기반 vs 연결 리스트 기반
| 비교 항목    | 배열 기반(ArrayStack) | 연결 리스트 기반(LinkedStack)      |
| -------- | ----------------- | --------------------------- |
| 메모리      | 연속 공간             | 비연속 공간                      |
| Overflow | 배열 크기 제한 존재       | 메모리 허용 범위 내에서 무제한           |
| 캐시 효율    | 매우 좋음             | 나쁨                          |
| 삽입/삭제    | 뒤(Top)에서만 → O(1)  | Head 또는 Tail에서 연결 조작 → O(1) |

⇒ 실무에서는 대부분 **배열 기반(`ArrayDeque`)** 를 사용한다.

### 4.3 함수 호출 스택 & 재귀
스택은 OS와 프로그램 실행에서 매우 중요한 역할을 한다.  
→ 함수 호출 시 "Return Address", "지역 변수", "매개 변수" 등이 **스택 프레임(Stack Frame)** 으로 저장된다.  

⇒ 따라서 **재귀 호출은 호출 스택을 기반으로 동작**한다.

## 5 큐(Queue)
> 큐는 **FIFO(First In, First Out: 선입선출)** 방식의 선형 자료구조이다.  
> → 먼저 들어간 데이터가 먼저 나온다.

### 5.1 주요 연산
| 연산           | 설명             | 시간복잡도 |
| ------------ | -------------- | ----- |
| `enqueue(x)` | 뒤(Rear)에 요소 추가 | O(1)  |
| `dequeue()`  | 앞(Front) 요소 제거 | O(1)  |
| `peek()`     | 첫 요소 확인        | O(1)  |
| `isEmpty()`  | 비어 있음 여부       | O(1)  |

**`dequeue()` 시에는 Underflow(큐가 비어있는데 제거하는 것)를 고려해야** 한다.

### 5.2 원형 큐(Circular Queue)
일반 배열 기반 큐는 **Dequeue를 반복하면 앞쪽에 빈 공간이 생기지만 사용하지 못한다**.  
→ 비효율적이다.  
→ **원형 큐를 사용해서 배열을 재활용**한다.  
→ 공간 낭비 방지

```java
rear = (rear + 1) % size; // Enqueue
front = (front + 1) % size; // Dequeue
```
위와 같이 mod 연산으로 순환한다.

### 5.3 연결 리스트 기반 vs 배열 기반
| 기준     | 배열 기반 큐  | 연결 리스트 기반 큐 |
| ------ | -------- | ----------- |
| 메모리    | 연속 메모리   | 노드 별 비연속    |
| 구현 난이도 | 원형 처리 필요 | 상대적으로 간단    |
| 삽입/삭제  | O(1)     | O(1)        |
| 캐시 효율  | 좋음       | 나쁨          |

**배열 기반의 경우 Overflow를 추가로 고려해야** 한다.  
→ 동적 확장을 지원하는 원형 큐는 Overflow 시에 더 큰 배열을 새로 할당하도록 한다.

### 5.4 예시
| 상황                | 이유                |
| ----------------- | ----------------- |
| CPU 스케줄링          | 먼저 도착한 프로세스 먼저 처리 |
| 버퍼(Buffer), 메시지 큐 | 데이터가 도착한 순서대로 처리  |
| 네트워크 패킷 처리        | 순서 보장 필요          |
| BFS (너비 우선 탐색)    | 레벨 순으로 순차 탐색      |
| 생산자-소비자 패턴        | 동기화 큐             |

## 6 덱(Deque: Double-ended Queue)
> 덱(Deque)은 앞과 뒤 **양쪽에서 삽입/삭제가 가능한** 선형 자료구조이다.  
> → 스택 + 큐의 특징을 모두 가진다.

자바에서는 `Stack` 대신 `Deque`를 사용하는 것을 권장한다.  
(`Stack`의 경우 `Vector` 기반이라 동기화가 과도하게 적용되어 성능상 좋지 않을 수 있다.)

### 6.1 주요 연산
| 연산             | 설명          | 시간복잡도 |
| -------------- | ----------- | ----- |
| `pushFront(x)` | 맨 앞에 데이터 삽입 | O(1)  |
| `pushBack(x)`  | 맨 뒤에 데이터 삽입 | O(1)  |
| `popFront()`   | 맨 앞에서 제거    | O(1)  |
| `popBack()`    | 맨 뒤에서 제거    | O(1)  |

### 6.2 ArrayDeque / LinkedList의 차이 (Java)
| 자료구조   | ArrayDeque          | LinkedList |
| ------ | ------------------- | ---------- |
| 기반     | 배열(원형)              | 연결 리스트     |
| 성능     | 대부분 더 빠름            | 포인터 오버헤드   |
| 메모리 효율 | 좋음                  | 나쁨         |
| 추천 사용  | Deque, Queue, Stack | 거의 추천 안함   |

### 6.3 Sliding Window 활용
덱(Deque)의 가장 대표적인 알고리즘 활용이 **슬라이딩 윈도우** 문제이다.  

새로 들어온 값보다 작은 값(또는 큰 값) 제거  
→ 덱을 항상 내림차순(또는 오름차순)으로 유지  
→ **덱의 앞쪽 값은 항상 윈도우 내 최댓값(또는 최솟값)**
