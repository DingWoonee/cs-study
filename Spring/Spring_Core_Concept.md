# 스프링 핵심 원리(Spring Core Concepts)
### 📚 목차
- [1 스프링 프레임워크 개요](#1-스프링-프레임워크-개요)
- [2 IoC & DI (스프링 객체 관리 핵심)](#2-ioc--di-스프링-객체-관리-핵심)
- [3 AOP(Aspect-Oriented Programming)](#3-aopaspect-oriented-programming)
- [4 스프링 MVC 아키텍처](#4-스프링-mvc-아키텍처)
- [5 스프링 요청 처리 전체 흐름](#5-스프링-요청-처리-전체-흐름)
- [6 스프링 빈 생명주기 & 확장 포인트](#6-스프링-빈-생명주기--확장-포인트)
- [7 스프링 부트 자동 구성 원리](#7-스프링-부트-자동-구성-원리)

## 1 스프링 프레임워크 개요
### 1.1 스프링이란 무엇인가?
> 자바 기반 엔터프라이즈 애플리케이션(웹 서비스, 백엔드 서비스)을 만들기 위한 프레임워크 집합

- **POJO 기반**  
  평범한 자바 객체(Plain Old Java Object, POJO) 중심으로 개발할 수 있게 해준다.  
  → 순수 비즈니스 로직으로 테스트 및 유지보수가 쉬워짐
- **IoC/DI 중심**  
  프레임워크(컨테이너)가 객체 생성 및 연결을 대신해준다.  
  → 개발자는 비즈니스 로직에 집중
- **인프라 추상화**  
  트랜잭션, 보안, 데이터 접근, 메시징 등의 기능들을 공통된 방식으로 묶어 제공한다.  
  → 특정 기술에 의존하지 않고, 스프링을 통해 추상 계층으로 다룸

### 1.2 스프링의 등장 배경
- **EJB의 문제점**
  - 너무 무겁고 복잡함
  - 비즈니스 로직보다 기술 코드가 많음
  - 테스트가 거의 불가능함
  - 개발 비용이 너무 높음

- **스프링의 목표**
  - POJO 기반 개발 → 상속/인터페이스 제약 없이 순수 자바 코드로 개발
  - IoC/DI 제공 → 객체를 직접 생성/관리하지 않아도 됨
  - AOP 기반 선언적 트랜잭션 → 공통 기능을 AOP로 별도로 분리
  - 가벼운 컨테이너 → JVM만 있어도 스프링 실행 가능

### 1.3 스프링과 스프링 부트 관계
> Spring은 핵심 기술이고,  
> Spring Boot는 Spring을 쉽고 빠르게 사용할 수 있게 만든 시작 도구이다.

- **스프링 프레임워크**  
  IoC 컨테이너, AOP, MVC 등 기능 그 자체

- **스프링 부트**  
  - starter 의존성 제공
  - 자동 구성(AutoConfiguration)
  - 내장 서버(Tomcat, Jetty, Netty)
  - `application.yml` 기반 설정
  - 배포 단순화(Jar 하나로 동작)

## 2 IoC & DI (스프링 객체 관리 핵심)
### 2.1 IoC 개념
> IoC(Inversion of Control)는 객체의 생성과 제어 권한을 개발자가 아닌 외부 컨테이너가 갖는 것을 말한다.  
> 원래 개발자에게 있던 권한이 프레임워크로 옮겨졌기 때문에 **제어의 역전(IoC)**라고 한다.

→ 객체를 직접 생성하지 않음  
→ 스프링 컨테이너가 대신 객체를 생성하고, 연결한다.

- **IoC가 필요한 이유**  
  1. 객체 생성/초기화/연결 로직이 여기저기 흩어진다. → 유지보수가 어려움
  2. 구현체를 바꾸려면 코드 수정이 필요함 → 결합도가 높아짐
  3. 테스트를 하려면 가짜 객체를 넣기 어려움 → 테스트 비용 증가
  4. 애플리케이션 규모가 커질수록 객체 조립 구성이 복잡해짐
  
### 2.2 DI 개념
> DI는 **필요한 객체(의존성)를 외부에서 넣어주는 기법**이다.  
> IoC가 개념이라면, DI는 그것을 실현하는 구체적인 방식이다.

- **DI가 강력한 이유**
  - 구현체를 외부에서 선택해서 변경에 유연하다.
  - 테스트 시 Mock 객체 주입으로 테스트가 쉽다.

- **주입 방식**
  - **생성자 주입**  
    생성자를 통해 **의존성을 객체 생성 시점에 넣는 방식**이다.  
    
    → `final`을 통해 불변을 보장할 수 있다.  
    → 객체 생성 시점에 필요하기 때문에 누락이 방지된다.  
    → 순환 참조를 빠르게 감지할 수 있다.
  
  - **Setter 주입**  
    객체 생성 후 Setter로 주입하는 방식이다.  
    Setter 함수에 `@Autowired`를 붙여서 사용할 수 있다.  

    의존성이 필수는 아니고 선택적인 경우나 런타임 중에 변경해야 하는 경우 사용할 수 있다.
    
  - **필드 주입**  
    필드에 `@Autowired`를 붙여서 사용하는 방식으로,  
    자바의 리플렉션(reflection)을 사용해서 직접 객체를 꽂아 넣는다.  
    (리플렉션으로 `@Autowired`가 붙은 필드를 찾는다.)

- **생성자 주입이 권장되는 이유**  
  - 의존성이 빠짐없이 주입된 완전한 객체만 생성될 수 있다. → 불변성 보장
  - 생성자 주입 단계에서 순환 참조 감지
  - 테스트가 쉬움 (필드 주입의 경우 private 필드를 직접 넣을 수 없고, Setter 주입은 Setter 메서드가 열려있어야 한다.)
  - DI 컨테이너 없이도 객체 생성 가능 → 테스트가 편해짐
  - `final`을 통해 불변성 보장 가능

### 2.3 IoC 컨테이너 구조
> IoC 컨테이너는 객체를 직접 `new`로 생성하지 않고,  
> 스프링이 대신 생성하고 초기화하고 의존성을 주입해주고 소멸까지 관리하는 객체이다.

- **`BeanFactory`**  
  스프링 IoC 컨테이너의 최상위 인터페이스  
  빈 생성 및 조회, 의존성 주입 같은 **기본 기능**을 제공  
  → 스프링 컨테이너의 최소 기능
  
- **`ApplicationContext`**  
  `BeanFactory`를 확장한 컨테이너  
  (실무에서는 거의 이걸 사용한다.)  
  국제화, 이벤트 발행, AOP, 환경 변수 관리 등의 기능 제공

### 2.4 스프링 DI 구현 방식
- **컴포넌트 스캔(`@ComponentScan` + `@Component` 등)**  
  `@Component`, `@Service`, `@Repository`, `@Controller` 등이 붙은 클래스를 자동으로 검색해서 빈으로 등록한다.

- **자바 설정(`@Configuration` + `@Bean`)**  
  개발자가 직접 빈을 등록하는 방식으로, Configuration 클래스에서 등록한다.

- **생성자 DI + `@Autowired`**  
  스프링은 생성자를 통해 빈을 주입한다.  
  스프링 4.3부터 생성자가 1개면 `@Autowired`가 생략 가능하다.  
  (보통 `@RequiredArgsConstructor`를 많이 사용함)

### 2.5 설계 원칙(DIP, OCP)과 DI
- **DIP(의존성 역전 원칙)**  
  > 고수준 모듈은 저수준 모듈에 의존하면 안된다.  
  > 둘 다 추상화(인터페이스)에 의존해야 한다.

  인터페이스를 의존하고 구현체를 빈으로 등록하면 이 원칙을 지킬 수 있다.  
  → 클래스 내부에서는 인터페이스만 의존하고 `new` 등의 작업을 할 필요가 없다.

- **OCP(개방-폐쇄 원칙)**  
  > 확장에는 열려 있고, 변경에는 닫혀있어야 한다.

  빈으로 등록하는 구현체만 바꾸면 되기 때문에  
  인터페이스를 의존하는 클래스의 코드는 수정할 필요 없고, 구현 코드만 수정하면 된다.

## 3 AOP(Aspect-Oriented Programming)

## 4 스프링 MVC 아키텍처
<img width="772" height="353" alt="image" src="https://github.com/user-attachments/assets/e351973f-8b01-4997-91b6-5e67b01f5cd3" />


## 5 스프링 요청 처리 전체 흐름

## 6 스프링 빈 생명주기 & 확장 포인트
### 6.1 Bean LifeCycle
### 6.2 BeanPostProcessor / FactoryPostProcessor
### 6.3 커스텀 확장 포인트

## 7 스프링 부트 자동 구성 원리
### 7.1 AutoConfiguration 동작 원리
### 7.2 조건부 빈 등록(Conditional 계열)
### 7.3 SpringFactoriesLoader / AutoConfiguration.imports
### 7.4 내장 서버 구조
