# HTTP/2
### 📚 목차
- [1 HTTP/2 등장 배경](#1-http2-등장-배경)
- [2 HTTP/2의 핵심 목표](#2-http2의-핵심-목표)
- [3 HTTP/2의 핵심 개념](#3-http2의-핵심-개념)
- [4 Flow Control & Priority](#4-flow-control--priority)
- [5 HAPCK (헤더 압축)](#5-hapck-헤더-압축)
- [6 HTTP/2 연결 수명 주기](#6-http2-연결-수명-주기)
- [7 HTTP/2와 TCP의 관계](#7-http2와-tcp의-관계)
- [8 HTTP/2 실전 성능 이슈](#8-http2-실전-성능-이슈)

## 1 HTTP/2 등장 배경
> [요약]  
> HTTP/1.1이 "한 연결에서 요청을 직렬로 처리하는 구조"라서,  
> 웹이 커질수록 지연이 구조적으로 커졌기 때문이다.

### 1.1 HTTP/1.1의 구조적 한계
- **HOLB(Head-of-Line Blocking)**

  앞의 요청이 느리면 뒤의 요청들이 다 막히는 성능 저하 현상을 말한다.
  
  → HTTP/1.1은 같은 연결에서 응답이 온 후에 다음 요청을 보낼 수 있음  
  (HTTP/1.1 pipelining인 경우에는 응답을 기다리지 않고 다음 요청을 계속 보내긴 한다.  
  하지만, pipelining을 사용하더라도 이전 응답이 늦어짐으로 인한 HOLB는 피할 수 없다.)

- **브라우저의 다중 연결**

  HTTP/1.1의 경우는 HOLB을 해결할 방법이 없기 때문에  
  브라우저는 연결을 여러개 만들어서 동시에 요청을 보내고 응답을 받는다. (보통 최대 6개)

  → TCP 연결 수 증가로 인한 오버헤드 발생  
  (TCP handshake, TLS handshake, TCP slowstart, 관리해야 하는 연결 증가 등)

- **헤더 중복 전송**

  HTTP/1.1은 헤더가 바뀐 것이 없어도 그대로 반복 전송한다.  
  → 대역폭 낭비  
  → 특히 모바일/고지연 환경에서 더 치명적

- **한계를 피하려 하다보니 개발 복잡도가 증가함**

  **도메인 샤딩**: 서브 도메인을 늘려서 도메인 연결 제한 우회

  **스프라이트**: 이미지 여러 개를 한 장으로 합침  
  → 빌드/캐싱/부분 갱신이 어려워짐

  **번들링/인라이닝**: js와 css을 html에 합침 / 이미지를 base64 인코딩해서 html에 합침

### 1.2 SPDY → HTTP/2 표준화 과정
- **구글의 SPDY**

  구글이 SPDY(스피디)를 만들어서 하나의 TCP 연결 위에서 요청을 여러 개 동시에(멀티플렉싱) 흘려보내고 헤더를 압축하면,  
  웹이 빨리지는 것을 보여줬다.

  → 이를 IETF가 표준화했고, 그것이 HTTP/2이다.

## 2 HTTP/2의 핵심 목표
> [요약]  
> 연결 수를 늘리지 않고, 한 연결에서 더 많이/더 효율적으로/더 빨리 처리하자

### 2.1 지연(latency) 감소 전략
- **요청 직렬화 제거 (Multiplexing 전제)**

  HTTP/1.1의 지연은 대부분 **대기**에서 발생했다.

  → HTTP/2의 목표는 **요청을 동시에 보내면서 응답도 동시에 받을 수 있게**하는 것이다.  
  → 지연의 원인을 실제 서버 처리 시간에 더 가까워지게

- **연결 재사용 극대화**

  여러 연결을 사용하던 것을 하나의 연결로 바꾸면서  
  TCP handshake, TLS handshake 비용을 최소화했다.

### 2.2 네트워크 효율 개선
- **헤더 전송 비용 최소화**

  헤더를 반복 전송하는 HTTP/1.1과 다르게  
  HTTP/2는 헤더를 저장하자 → 고지연 환경에서 효과 극대회

- **불필요한 패킷 왕복 감소**

  **작은 요청이 많으면** 패킷 수가 폭증함.  
  HTTP/2는 여러 요청을 묶어 보낸다.

### 2.3 서버/클라이언트 리소스 절약
- **서버 관점**

  HTTP/2에서는 적은 열결 수로 더 많은 요청 처리  
  → 스케일링 예측 가능성 증가

- **클라이언트 관점**

  리소스 요청 로직 단순화  
  (HTTP/1.1의 한계를 극복하기 위한 올라간 개발 복잡도 정상화)

### 2.4 웹 생태계 복잡도 감소
HTTP/1.1의 한계를 극복하기 귀한 여러 복잡한 것들을 정상화하자!!  
→ 작은 리소스를 작은 단위로 요청해도 OK!!

→ 성능 때문에 아키텍처를 희생하지 않아도 된다.

## 3 HTTP/2의 핵심 개념
### 3.1 Binary Framing Layer
HTTP/1.1는 텍스트 기반이었지만, HTTP/2는 **바이너리(프레임)로 쪼개**서 보낸다.

- **HTTP/1.1**

  ```http
  GET /api/profile HTTP/1.1
  Host: example.com
  User-Agent: Chrome/120
  Cookie: session=abc
  Accept: application/json
  ```
  - 헤더와 바디를 문자열(줄바꿈)로 판단함  
  - 프로토콜 확장이 어려움(고정된 형태)  
  
- **HTTP/2**

  ```text
  00 00 2a    // Length (42 bytes)
  01          // Type = HEADERS
  05          // Flags = END_HEADERS | END_STREAM
  00 00 00 01 // Stream ID = 1
  
  82 86 84 41 8c f1 e3 c2 e5 f2 3a 6b a0 ab 90 f4 ff
  ```
  - 파싱이 빠르고 명확함
  - 프로토콜 확장이 쉬움 (새 프레임 타입 추가)
  - 프레임 단위여서 멀티플렉싱 구현이 쉬움

### 3.2 Stream / Message / Frame 구조
