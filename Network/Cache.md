# Cache
## 1 캐시의 기본 개념
### 1.1 캐시란?
> **비싼 작업의 결과**를, 더 가까운 곳에/더 빠른 저장소에/더 짧은 경로로 **저장해두고 재사용**하는 것

- **네트워크에서의 비싼 작업**  
  원격 서버까지 왕복하는 네트워크 비용  
  서버에서 다시 계산하거나 생성해야 하는 비용  
  링크 대역폭을 쓰는 비용(큰 리소스를 다운 받는 경우 등)

- **캐시의 핵심 사항**  
  1. 동일성 판단  
    → 요청의 동일성 여부를 어떻게 판단할 것인가
  2. 캐시 정책  
    → 같은 요청이라고 판단되면 바로 사용해도 되는가

### 1.2 네트워크에서 캐시가 필요한 이유
1. **지연 시간 (RTT) 감소**  
  데이터 전송 시간 뿐만 아니라 DNS 조회, TCP 연결, TLS 등의 비용이 발생한다.  
  → 캐시를 통해 원격 서버로의 왕복 자체가 일어나지 않을 수 있다.

2. **대역폭 절약**  
  정적 파일과 같이 비교적 큰 파일을 여러번 보내지 않게 되면 대역폭을 절약할 수 있다.  

  네트워크에서는 링크별로 정해진 **최대 전송 용량(대역폭)** 이 존재하고, 캐시를 통해 이를 절약할 수 있다.

3. **Origin 서버 부하 감소**  
  Origin 서버는 SoT(Source of Truth)를 갖고 있고, 요청이 몰리면 병목이 된다.  

  → 캐시를 통해 서버 계산과 DB 부하 감소

### 1.3 네트워크 캐시의 계층 구조 개요
> Browser → proxy → CDN → Origin

- Browser Cache  
  → 가장 가깝고 빠름  
  → 네트워크 자체를 생략 가능

- Proxy Cache  
  → 포워드 프록시: 회사/학교 같은 곳에서 외부로 가는 트래픽 제어 및 캐싱  
  → 리버스 프록시: 서버 앞단에서 응답 캐싱 및 Origin 보호  
  → 같은 네트워크 사용자들끼리 공유 가능 & 서버 앞단에서 제어

- CDN Cache  
  → 사용자와 물리적으로 가까운 곳에서 응답  
  → 정적 파일에서 효과가 극대화 (수정이 사실상 없어서 오래 재사용 가능)  

- Origin (원본 서버)  
  → 캐시 미스나 재검증 실패 시 최종적으로 도달

## 2 HTTP 캐시
### 2.1 HTTP 캐시의 기본 동작 원리
1. 클라이언트 요청 발생 시 브라우저와 중간 캐시에서 이미 저장된 응답이 있는지 확인
2. 캐시 엔트리에 존재하지 않으면 Origin 서버로 요청
3. 존재하면 Fresh인지 Stale인지 판단

### 2.2 Cache-Control 헤더
- **`max-age`**  
  ```http
  Cache-Control: max-age=60
  ```
  이 응답을 60초 동안 Fresh로 간주한다.  
  → 이 시간 동안은 재검증 없이 바로 사용 가능

- **`no-cache`**  
  ```http
  Cache-Control: no-cache
  ```
  "사용하기 전에 반드시 재검증하라"라는 뜻이다.  
  → **최신성이 중요한 API 응답**에 자주 사용

- **`no-store`**  
  ```http
  Cache-Control: no-store
  ```
  캐시에 저장하는 것을 아예 금지하는 헤더이다.  
  → 개인정보, 인증 토큰 등

- **`public / private`**  
  ```http
  Cache-Control: public
  Cache-Control: private
  ```
  `public` → 모든 캐시 저장 가능  
  `private` → 브라우저 캐시만 저장 가능 → 공유 캐시(CDN/프록시)는 저장 금지  
  → 로그인 후 개인과 페이지는 보통 `private` 사용

- **`must-revalidate`**  
  ```http
  Cache-Control: must-revalidate
  ```
  **Stale 상태**로 판단되는 경우 **반드시 재검증**  
  → 네트워크 오류 상황에서도 캐시를 사용하는 것보다 **차라리 실패하는 것이 나은 경우**  
  → 금융 관련 정보

### 2.3 Fresh / Stale 리소스 개념
**Fresh** → 유효 기간이 지나지 않은 캐시 데이터
**Stale** → 유효 기간이 지난 캐시 데이터 → 재검증 필요

### 2.4 조건부 요청 (Revalidation)
HTTP는 **Stale**이라고 해서 무조건 새 데이터를 받지 않는다.  
→ **조건부 요청으로 확인**한다.

- **ETag 기반**  
  ```http
  ETag: "abc123"
  If-None-Match: "abc123"
  ```
  → 서버가 `ETag`로 리소스의 **버전 식별자**를 제공한다.  
  → 클라이언트는 `If-None-Match`로 리소스의 이 버전이 아직 유효한지 체크한다.
  → 변경이 없으면 `304 Not Modified` 응답, 변경됐으면 `200 OK`과 바뀐 리소스 응답

- **Last-Modified 기반**  
  ```http
  Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
  If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
  ```
  → 서버가 응답 헤더로 `Last-Modified`를 보내준다.  
  → 클라이언트는 `If-Modified-Since`로 검증한다.  
  → **정밀도가 ETag보다 떨어진다.** (초 기준이기 때문에 변경이 짧은 시간이 잦을 경우 이를 정확히 반영하지 못한다.)

### 2.5 HTTP 메서드와 캐시
- **GET**  
  HTTP 캐시는 **GET 메서드 중심으로 설계**되었다.  
  일반적으로 캐시 가능하다.

- **POST/PUT/DELETE**  
  기본적으로 캐시하면 안된다.

## 3 캐시 키(Cache Key)와 캐시 분기
### 3.1 캐시 키의 기본 구성
- **URL**  
  ```
  GET /images/logo.png
  ```
  캐시 키의 절대적인 기본 단위로, 경로가 다르면 **무조건 다른 캐시**이다.  

- **Query String**  
  ```
  /products?id=1
  /products?id=2
  ```
  URL의 Query String이 다르면 **기본적으로 다른 캐시**이다.  
  (추적용 파라미터나 일부 정책적으로 무시할 수 있다.)

### 3.2 캐시 키에 영향을 주는 HTTP 요소
URL이 같다고 같은 응답이 아니다.  
→ HTTP Header의 영향

- **Authorization**  
  ```http
  Authorization: Bearer ...
  ```
  사용자별로 응답이 달라야 한다.  
  → Authorization이 있으면 캐시 분기. 또는 캐시 불가

- **Cookie**  
  ```http
  Cookie: session_id=...
  ```
  로그인 상태, 테스트 상황, 개인화에 따라 캐시가 필요할 수 있다.  
  → 캐시 키에 포함할 경우 캐시 분기가 많아져서 캐시가 폭발할 수 있고, 포함하지 않으면 데이터가 섞일 수 있다.

- **Accept-Encoding**  
  ```http
  Accept-Encoding: gzip, br
  ```
  인코딩 방식이 다르면 또한 다른 응답이다.

- **Accept-Language / User-Agent**  
  다국어 페이지  
  모바일/데스크톱 분기

### 3.3 캐시 키 설계 실수 사례
- **캐시 폭발 (Cache Explosion)**  
  너무 많은 Header와 Query를 Cache Key에 포함시킴  
  → 캐시가 Miss 나는 경우가 많고, 메모리만 차지한다.  
  → 캐시가 있어도 느리다.

- **사용자 데이터 혼합 (Cache Poinsoning)**  
  Authorization / Cookie 무시  
  → A 사용자 응답을 B가 보게되고 부정확한 정보를 제공하거나 보안 사고 발생

## 4 프록시 캐시
> 중간 계층 캐시로, "클라이언트와 Origin 서버 사이"에서 동작하는 캐시이다.  
> → 공유 캐시(shared cache)이다.

### 4.1 프록시 캐시의 개념
- **Forward Proxy (클라이언트 측 프록시)**  
  사용자가 인터넷으로 직접 나가지 않고, **프록시를 통해 인터넷으로 나간**다.  
  회사/학교/기관에서 흔하다.  

  - **주요 목적**  
    보안/감사 (로깅)  
    접근 제어 (차단)  
    트래픽 절감 (공용 캐시)

  - **캐시 관점의 특징**  
    같은 조직 내 여러 사용자가 같은 리소스를 요청하면 한 번만 외부에서 가져오고 공유 가능  
    HTTPS가 기본이라 **콘텐츠를 들여다보려면 복잡한 구성**이 필요해서 캐시 효과가 제한되는 경우가 많다.

- **Reverse Proxy (서버 측 프록시)**  
  **Origin 서버 앞**에 놓여서, 외부 요청이 바로 서버로 가지 않고 Reverse Proxy를 거친다.  

  - **주요 목적**  
    로드밸런싱 / 라우팅  
    TLS 종료  
    압축(gzip/br)  
    WAF(Web Application Firewall) 등의 보안  
    **캐싱**

  - **캐시 관점에서 Reverse Proxy**  
    브라우저 캐시는 사용자 단위이고 Forward Proxy는 특정 집단 단위이다.  
    → Reverse Proxy를 통한 캐싱은 **모든 사용자 요청을 캐싱**할 수 있다.  
    → Origin 서버를 보호할 수 있다. (성능 적으로)

### 4.2 Reverse Proxy 캐시 동작 구조 (Nginx)
1. **요청 수신**  
  클라이언트 → Reverse Proxy(Nginx)

2. **캐시 조회 (Cache Key로 lookup)**  
   URL, query, 일부 헤더로 만든 키로 캐시를 찾는다.

3. **Hit / Miss / Stale 판정**  
  **HIT**: 캐시 바로 응답  
  **MISS**: Origin으로 전달해서 응답을 받아 캐시 저장  
  **STALE**: 만료되었으면 정책에 따라 Origin에 재검증 or 새로 받아오기

4. **응답 반환**  
  Reverse Proxy → 클라이언트

- **Reverse Proxy 캐시가 저장하는 대상**  
  - 정적 파일
  - 캐시 가능한 GET 응답

- **Reverse Proxy 캐시의 실무 난제**  
  1. **캐시 키를 어떻게 잡을 것인가**  
    → 캐시 분기 설정
  2. **동시 MISS 폭주 (Cache Stamperde)**  
    → 리소스가 만료될 때 여러 사용자가 동시에 "같은 캐시 키"에 대해 동시에 MISS가 발생  
    → 같은 리소스를 요청하는 응답이 캐시를 통해서가 아니라 전부 Origin으로 전달됨  
    → MISS 폭주  
    → 락 등으로 해결

### 4.3 프록시 캐시와 HTTP 캐시의 관계
- **HTTP 헤더를 존중하는 프록시 캐시**  
  Origin이 `Cache-Control` 등으로 "캐시 가능/불가"를 지시  
  → **프록시는 HTTP 헤더 지시를 그대로 따라**서 저장/만료/재검증을 진행

  **장점** → 관리가 쉽다.  
  
  **단점** → Origin이 헤더를 잘못 주면 그대로 망한다. (캐시가 안되거나, 너무 오래되거나)

- **서버 주도 캐시 제어 (프록시가 정책을 오버라이드)**  
  Origin이 캐시 헤더를 약하게 줘도  
  → 프록시에서 "이 경로는 10초 캐시" 같은 식으로 강제로 캐싱 정책을 오버라이드할 수 있다.

  **장점** → 애플리케이션 수정 없이 **운영에서 캐시 정책 튜닝 가능**  
  → **빠른 대응** 가능

  **단점** → 프록시 캐시는 인프라 정책이기 때문에, 앱 정책(HTTP 캐시)과 충돌하면 문제가 생길 수 있다.  
  + 디버깅이 힘들다.

### 4.4 프록시 캐시의 한계
1. 개인화/상태 기반 응답은 캐시하기 어렵다.
2. 무효화가 어렵다.
3. 일관성(최신성)과 성능의 충돌이 있다. (적절한 조정이 필요)
4. 장애 시 "프록시가 SPOF"가 될 수 있다. (프록시의 역할에 따라 장애 발생 시 서비스 전체 장애)

## 5 CDN 캐시
> 글로벌 분산 캐시로,  
> CDN(Content Delivery Network)은 사용자와 물리적으로 가까운 Edge 서버에서 콘텐츠를 제공한다.

→ RTT 줄임 / 분산 환경으로 대역폭을 절약함 / Origin을 보호함

핵심은 **요청을 어떤 Edge로 보내고, 그 Edge가 어떤 정책으로 캐시/재검증/원본요청을 하는지**이다.

### 5.1 CDN 캐시의 기본 구조
1. **Edge Cache (PoP, Point of Presence)**  
  사용자가 실제로 접속하는 "가장 가까운 CDN 노드"이다.  
  → 여기서 Cache HIT이면 Origin까지 안 간다.  
  → CDN 성능 체감의 핵심

2. **Regional Cache (또는 Mid-tier / Parent Cache)**  
   Edge 뒤에 있는 상위 캐시 계층으로, Edge에서 MISS가 나도 바로 Origin으로 가지 않고 Regional을 한 번 더 조회하는 구조가 많다.  
   → Origin에 요청이 몰리는 것을 완화 (Origin 보호)

3. **Origin Server**  
   최종 원본 서버

### 5.2 CDN 캐시 동작 흐름 (Hit / Miss / Revalidate)

### 5.3 CDN에서의 캐시 정책 (TTL / Cache-Control 반영)

### 5.4 CDN에서의 동적 콘텐츠 캐싱

## 6 캐시 무효화(Cache Invalidation)
> "원본이 바뀌었을 때, 캐시는 어떻게 최신 상태로 돌아가는가?"  
> 이 질문을 해결하기 위한 것이 **캐시 무효화 전략**이다.

### 6.1 TTL 기반 만료

### 6.2 수동 무효화 (Purge / Invalidate)

### 6.3 Cache Busting 전략

### 6.4 캐시 무효화가 어려운 이유
1. 캐시는 계층적이다.
2. 캐시는 분산되어 있다.
3. 최신성과 성능은 항상 충돌한다. → 완벽한 해답은 없다.
4. 캐시 키가 잘못 설계되면 무효화도 무의미

## 7 캐시 설계 전략
