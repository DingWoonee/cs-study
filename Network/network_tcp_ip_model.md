# TCP/IP 모델
## 1 정의
인터넷에서 통신이 이루어지는 구조를 정의한 모델로, 총 4계층 구조로 이루어져 있다.  
OSI 7계층보다 현실적으로 단순화된 버전이다.

### 1.1 OSI 7계층과 비교
<img src="image/netword_tcp_ip_img1.png" width="70%"/>

(이미지 출처 - [나무위키: OSI 모형](https://namu.wiki/w/OSI%20%EB%AA%A8%ED%98%95?from=OSI))  

- **근본적 차이**  
    OSI 7계층은 통신의 기능을 이론적으로 표준화하기 위한 **참조 모델**로, **다양한 네트워크 시스템의 통신 과정을 설명**할 수 있다.  
    반면, TCP/IP 모델은 **실제 인터넷에서 동작하는 프로토콜을 기반**으로 통신 과정을 설명하는 모델이다.
    ⇒ TCP/IP 모델은 OSI 모델과 구조적으로 유사하지만 **그대로 적용되지 않으며, OSI의 개념을 현실적으로 구현한 형태**라고 볼 수 있다.
#### 공통점
- 계층 구조를 가진다.
- 계층 간 독립성이 있다.
- 데이터 전송 과정에서 캡슐화와 역캡슐화가 일어난다.
- 프로토콜 기반 설계이다.
#### 차이점
- **목적**  
    OSI 7계층 → 통신 표준화 모델 (이론 중심)  
    TCP/IP 4계층 → 인터넷 구현용 모델 (실무 중심)
- **응용 계층 범위**  
    OSI 7계층 → 3계층으로 분리되어 있다.  
    TCP/IP 4계층 → 1계층으로 통합되어 있다.
- **범용성**  
    OSI 7계층 → 어떤 네트워크 기술에도 적용 가능  
    TCP/IP 4계층 → 실제 인터넷 통신에서 사용

## 2 계층별 특징
### 1계층: 네트워크 접근 계층(Network Access Layer)
실제 물리적 네트워크를 통한 비트 단위 데이터 전송을 담당한다.  
→ OSI 7계층의 2계층과 1계층을 합친 것에 대응한다.  
→ 패킷을 전기 신호나 무선 신호로 바꿔서 실제로 전달하는 역할을 한다.
- **데이터 단위**: 프레임(Frame)
- **전송 주소**: MAC 주소
- **기능**  
    프레임(Frame) 단위로 전송  
    MAC 주소를 통한 인접 노드 식별  
    오류 검출 (CRC 등)  
    물리 전송
- **대표 프로토콜**  
    Ethernet, WiFi, PPP, ARP(2계층과 3계층 사이의 주소 변환 프로토콜)
- **OSI 7계층의 1계층과 2계층을 묶은 이유?**  
    그 두 계층이 **데이터를 비트 단위로 변환하고 실제로 전송하는 역할**을 하기 때문이다.  
    네트워크 접근 계층은 **LAN 구간에서의 데이터의 물리적 전송을 담당**하며, 실제 하드웨어(L2 스위치와 NIC, 케이블)를 통해 데이터를 전달한다.  
    반면 상위 계층은 경로를 설정하고 신뢰성 있는 연결을 보장하는 등의 논리적 제어를 담당한다.

### 2계층: 인터넷 계층(Internet Layer)
데이터를 목적지까지 전달하는 **길을 찾는 계층**이다.  
→ 현재 라우터에서 다음 라우터로, 즉 한 홉(hop) 단위로 데이터를 전달하는 역할을 한다.(전체 경로를 관리하지 않는다.)  

인터넷 계층은 **Best-Effort(최선형 서비스)**를 목표로 데이터를 목적지로 가능한 한 빨리 전달하는 것을 목표로 한다.(할 수 있는 한 최선을 다하지만, 결과는 보장하지 않음)  
→ 전송의 신뢰성이나 순서 보장, 재전송 등은 지원하지 않는다.  
→ 전체 경로의 신뢰성 있는 연결은 상위 계층의 TCP가 보장한다.
- **데이터 단위**: 패킷(Packet)
- **전송 주소**: IP 주소
- **기능**  
    논리적 주소 지정(IP Addressing)  
    라우팅(Routing)  
    패킷 전달 → 각 라우터가 다음 홉으로 패킷을 전달  
    단편화(Fragmentation) → MTU를 초과하는 패킷을 여러 조각으로 나누어 전송
    오류 및 제어 메시지 전달
- **프로토콜**  
    IP, ICMP, IGMP
### 3계층: 전송 계층(Transport Layer)
종단 간(end-to-end) 신뢰성 있는 데이터 전송을 담당한다.  
**프로세스 간의 데이터 전달을 담당**한다.  
→ IP 주소 수준이 아니라 **포트 번호 수준** 간 통신
- **데이터 단위**: Segment/Datagram
- **전송 주소**: Port
- **주요 기능**  
    종단 간 통신  
    세그먼트화  
    다중화와 역다중화  
    오류 검출  
    (TCP) 신뢰성 보장, 흐름 제어, 혼잡 제어, 순서 보장
- **프로토콜**  
    TCP, UDP
### 4계층: 응용 계층(Application Layer)
전송 계층(TCP/UDP)을 이용해 네트워크 서비스를 사용하도록 돕는 인터페이스 계층이다.  
OSI 7계층의 5~7계층에 해당한다.  
→ 데이터 표현 + 세션 관리 + 실제 서비스
- **주요 기능**  
    응용 서비스 제공  
    데이터 표현 및 인코딩  
    세션 관리  
    사용자 인터페이스 제공
- **프로토콜**  
    HTTP, FTP, SMTP, DNS, TLS, SSH
- **OSI 7계층의 5, 6, 7계층이 어떻게 이 응용 계층 하나로 합쳐진 것인지?**  
    세션 계층과 표현 계층, 응용 계층은 실제 인터넷 통신에서 명확히 분리된 구현이 어렵고, **대부분의 프로토콜이 이 세 가지 기능을 하나의 응용 계층 안에서 통합적으로 처리**한다.  
    → 이 때문에 TCP/IP 모델에서는 응용 계층 하나로 합쳐졌다.  
    **ex)** HTTP에서는 쿠키를 통해 세션을 제어하고, Accept 헤더를 통해 표현 방식을 협상하는 등의 작업을 수행한다. 또한 HTTPS에서는 여기에 SSL/TLS를 결합해 암호화와 인증 기능까지 수행한다.

## 3 송수신 과정
각 계층은 **버퍼(buffer) 형태의 메모리 공간**을 사용해서 데이터를 주고받는다.  
→ 데이터를 복사해서 전달하는 것이 아니라 **포인터(참조)**를 이용해 계층 간 버퍼를 공유한다.  
즉, 데이터는 한 번 메모리에 적재된 뒤, 각 계층이 자신의 헤더를 추가하거나 제거하는 방식으로 처리된다.  
(데이터의 복사는 최소화되고, 커널 버퍼 체인을 통해 연결된다.)
- **데이터의 복사가 최소화되면서 어떻게 헤더를 추가하고 제거하는지?**  
    **앞부분에 여유 공간(headroom)을 둔 버퍼를 미리 할당**해 두고, 각 계층이 그 앞쪽에 자신의 헤더를 붙이며 포인터를 당겨 쓰는 구조를 사용한다.
    헤더 제거 시에도 앞쪽 포인터를 이동하는 방식을 사용한다.
- **리눅스의 `sk_buff` 구조체**  
    <img src="image/network_tcp_ip_layer_img2.png" width="70%"/>

    (이미지 출처 - [티스토리](https://thinking-bank.tistory.com/20))  
    리눅스 커널의 `sk_buff` 구조체는 계층 간 데이터를 복사하지 않고 전달하기 위한 포인터 필드를 가진다.  
    `head`/`end`: 버퍼의 시작과 끝(메모리 전체 경계)  
    `data`/`tail`: 현재 유효 데이터의 시작과 끝 → 헤더 추가/제거 시 이동  
    ⇒ `sk_buff`는 `head/data/tail/end` 포인터로 하나의 버퍼를 관리하며, 계층 간에는 `sk_buff` 포인터 하나만 넘기고 포인터를 조작해 헤더를 얹고 벗긴다.
### 3.1 송신 과정
송신 과정에서는 계층을 거칠 수록 각 계층의 헤더가 앞에 더해지는 **캡슐화(Encapsulation)** 과정이 일어난다.  
1. **응용 계층 → 전송 계층**  
    응용 계층의 데이터를 소켓(socket)을 통해 전송 계층으로 전달한다.  
    (소켓은 응용 프로세스와 전송 계층을 연결하는 커널 내부의 인터페이스 역할을 한다.)
2. **전송 계층 → 인터넷 계층**  
    전송 계층은 응용 데이터 앞에 TCP(또는 UDP) 헤더를 붙여 세그먼트(또는 데이터그램)를 생성한다.  

    또한, 전송 계층은 MTU를 고려하여 세그먼트 크기를 조정하며, IP 계층에서 불필요한 단편화가 발생하지 않도록 한다.
3. **인터넷 계층 → 네트워크 접근 계층**  
    인터넷 계층은 세그먼트 앞에 IP 헤더를 추가해 패킷(Packet)을 만든다.  
    패킷은 이후 네트워크 접근 계층으로 전달되어, MAC 주소를 포함한 프레임(Frame)으로 캡슐화된다.    
### 3.2 수신 과정
수신 과정에서는 송신 과정의 반대로 일어난다.  
각 계층은 하위 계층으로부터 데이터를 받아 자신의 헤더를 제거하며, 필요한 정보를 해석한 뒤 상위 계층으로 전달한다.  
→ 이를 **역캡슐화(Decapsulation)**라고 한다.
1. **네트워크 접근 계층 → 인터넷 계층**  
    수신된 신호가 프레임으로 복원되고, 목적지 MAC 주소가 자신과 일치하면 IP 계층으로 전달된다.  
    이때 이더넷 헤더는 제거된다.
2. **인터넷 계층 → 전송 계층**  
    IP 계층은 IP 헤더를 해석하여 목적지 IP를 확인하고, IP 헤더의 Protocol 필드를 통해 상위 프로토콜(TCP/UDP)을 결정한다.  
    → 해당 프로토콜의 처리 함수를 호출하며 세그먼트를 전달한다.
3. **전송 계층 → 응용 계층**  
    전송 계층은 포트 번호를 이용해 해당 응용 프로그램에 연결된 소켓을 찾는다.  
    세그먼트의 헤더를 제거하고, 응용 데이터를 소켓의 수신 버퍼에 저장한다.  
    → 응용 프로그램이 이 데이터를 읽어서 처리한다.