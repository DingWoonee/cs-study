# Keep-Alive와 HTTPS
### 📚 목차
- [1 HTTP 통신의 기본 전제](#1-http-통신의-기본-전제)
- [2 HTTP Keep-Alive 개요](#2-http-keep-alive-개요)
- [3 Keep-Alive의 내부 동작](#3-keep-alive의-내부-동작)
- [4 Keep-Alive의 장단점](#4-keep-alive의-장단점)
- [5 HTTPS 개요](#5-https-개요)
- [6 TLS Handshake](#6-tls-handshake)
- [7 HTTPS와 Keep-Alive의 관계](#7-https와-keep-alive의-관계)

## 1 HTTP 통신의 기본 전제
### 1.1 HTTP는 Stateless
HTTP는 기본적으로 **각 요청이 독립적**이다.  
→ 어떤 요청이 이전의 클라이언트와 같은 클라이언트인지, 로그인된 상태인지  
HTTP 자체만으로 기억하지 않는다.

- **Stateless로 설계된 이유**  
  1. 확장성(Scale-out)이 압도적으로 쉽다. → 여러 서버 중 하나로만 보내면 됨
  2. 장애 내성이 좋아진다. → 장애 시 다른 서버가 처리
  3. 프로토콜이 단순하다. → 리소스 중심

### 1.2 TCP 연결 비용
HTTP 요청이 오가기 위해서는 먼저 TCP 연결이 필요하다.  
→ 이것이 **"느림"의 원인**이다.  

TCP 연결을 위해서는 최소 3번의 패킷이 클라이언트와 서버 사이를 이동해야 한다.

### 1.3 "요청 하나 = 연결 하나"의 문제점
초기 HTTP 모델로 요청을 하면, 모든 요청마다 TCP 연결을 새로 만들고, 응답을 받으면 끊었다.  
→ 이 방식을 여러 문제가 있었다.  

1. **지연(latency) 폭증**  
   요청 하나마다 TCP handshake 및 TLS handshake 비용 발생  
   → 이 이후에 HTTP 요청/응답 메시지 전송  
   → 데이터가 얼마 없는 상황에서는 **연결 세팅 비용이 지연의 대부분을 차지**  
2. **서버 리소스 소모**  
   모든 연결은 공짜가 아니다.  
   → 모든 연결 마다 소켓 생성 및 커널 자료구조, TIME_WAIT 같은 상태 관리가 필요하다.  
3. **TCP slow start**  
   TCP의 새 연결은 보통 slow start로 시작한다.  
   → 연결을 계속 새로 만들면 매번 속도를 내지 못하고 초반에 끊긴다.

## 2 HTTP Keep-Alive 개요
### 2.1 Keep-Alive 등장 배경
매 HTTP 요청마다 새로운 연결이 설정되었다.  
→ 그로 인해 1.3에서 본 여러 문제(지연 폭증, 서버 리소스 소모, TCP slow start 등)가 발생했다.  

⇒ 연결을 끊지 말고 유지해서 재사용하자

### 2.2 Persistent Connection
> Persistent Connection(지속 연결)은 **TCP 연결 1개를 열어**두고,  
> 그 위로 HTTP 요청/응답을 여러 번 주고받는 것이다.

- **주의 사항**  
  Keep-Alive는 **연결을 재사용**하는 것이지, '병렬 처리'는 아니다.  
  → HTTP/1.1에서는 다중화를 지원하지 않아서 요청-응답 순서를 지켜야한다.  

### 2.3 HTTP/1.0 vs HTTP/1.1 Keep-Alive 차이
Keep-Alive는 HTTP 헤더의 **`Connection: keep-alive`를 통해 명시**한다.

- **HTTP/1.0**  
  디폴트는 **Non-Persistent**로, 요청 1번 하고 연결을 끊는 방식이다.  
  → Keep-Alive는 확장(옵션)이고, **헤더로 명시해야 유지**된다.

- **HTTP/1.1**  
  **Persistent Connection이 기본 동작**이고, 그렇게 구현되어있다.  
  → 연결을 종료하고 싶으면 `Connection: close`를 명시해야 한다.

### 2.4 Keep-Alive 기본 동작 흐름
1. 연결 생성
2. 첫 요청/응답
3. 연결을 닫지 않고 Idle 상태로 둠
4. 같은 서버로 다음 요청이 필요하면 재사용
5. 종료 조건이 오면 종료

- **주의: 영원한 유지가 아니다.**  
  Keep-Alive는 명시적으로 종료하기 전까지 영원한 유지가 아니다.  
  → 서버 정책(Timeout/Max requests), 프록시 정책, 클라이언트 정책, 네트워크 상황에 따라 결정된다.

## 3 Keep-Alive의 내부 동작
### 3.1 커넥션 풀(Connection Pool) 개념
> 요청을 보내는 쪽(클라이언트)은  **커넥션 풀**을 통해 열려 있는 **TCP 연결을 보관**하고,  
> 필요할 때 재사용한다.

→ **(host, port, protocol)** 단위로 풀을 관리한다.  
→ 클라이언트는 요청을 보낼 때 연결을 매번 새로 만들지 않고, 이미 만들어 둔 연결을 재사용한다.

### 3.2 Keep-Alive Timeout / Max Requests
2.4에서 말했듯이 Keep-Alive는 "영원한 유지"가 아니다.  
→ 서버와 클라이언트는 **정책에 따라 관리**한다.

- **Keep-Alive Timeout**  
  > 연결이 Idle(아무 요청도 안오는 상태)로 유지되는 최대 시간  

  이 시간이 지나면 서버는 연결을 닫아버릴 수 있다.  
  ex) Nginx: `keepalive_timeout 65s;`

- **Max Requests (또는 Max Keep-Alive Requests)**  
  > 하나의 연결에서 처리할 수 있는 요청 개수 제한  

  하나의 연결을 너무 오래 사용하면 장시간 연결로 누수나 비정상 상태가 생길 수 있다.  
  → **일정 간격으로 연결을 리셋**해주는 것이 좋다.

  클라이언트는 요청 실패 시에 자동으로 다시 연결을 설정하고, 기존 연결을 커넥션 풀에서 제거한다.

- **클라이언트 관점**  
  1. 요청 보낼 때 풀에서 연결 하나 획득
  2. 없으면 새로 생성
  3. 응다 받으면 연결을 풀로 반환
     
  → **지연 최소화 + 재사용 극대화**

- **서버 관점**  
  - 너무 오래 Idle → close
  - 너무 많이 사용 → close
  - 부하가 커지면 keep-alive timeout을 짧게 설정

  → **서버 리소스 보호**

### 3.3 OS 레벨(TCP) Keepalive와의 차이
- **HTTP Keep-Alive**  
  애플리케이션 레벨  
  성능 최적화를 위함

- **TCP Keepalive**  
  OS 레벨  
  연결 생존 여부 확인을 위함 → 아직 상대가 살아 있나?

⇒ **HTTP Keep-Alive는 재사용을 위한 것이고, TCP Keepalive는 연결이 살아 있는지 확인하기 위한 것이다.**

## 4 Keep-Alive의 장단점
### 4.1 장점
- **RTT 감소 (지연 감소)**  
  Keep-Alive를 통해 매 요청마다 해야하는 TCP handshake 및 TLS handshake 오버헤드가 사라진다.
- **TCP / 소켓 비용 절감**  
  소켓 생성/닫기 및 커널 자료구조 할당/해제, TIME_WAIT 관리 등에서 오는 추가 작업이 줄어든다.

### 4.2 단점
- **리소스 점유**  
  > 요청이 없더라도 "열려 있는 연결"은 서버 리소스를 계속 잡아먹는다.  
  > → Keep-Alive의 근본적인 단점  

  → 연결 하나당 FD, 소켓 버퍼 메모리, 커널 상태, 프록시 리소스 등을 점유한다.  
  
  ⇒ **사용자가 많고 요청 빈도가 낮은 상황**이면 idle connection이 엄청 쌓여서 서버 리소스에 문제가 생길 수 있다.

- **Connection Leak 위험**  
  클라이언트가 연결을 풀에서 빌려가고 반환을 안 하는 경우  
  → 애플리케이션 레벨 누수 발생  
  ex) 자바의 `HttpClient`/`OkHttp`/`RestTemplate`/`WebClient` 등에서 close 누락  

  timeout 설정이 너무 긴 경우  
  → 누수는 아니지만 사실상 누수 상황과 유사하고, Idle connection이 폭증할 수 있다.

### 4.3 문제가 되는 상황
Keep-Alive에 대해 **언제 문제가 생길 수 있는지** 명확히 알아야 한다.  

1. **트래픽이 사용자는 많지만 요청 빈도가 낮은 경우**  
   
2. L**B/프록시/방화벽의 timeout 불일치**  
   → 클라이언트는 연결이 살아있다고 생각하고 재사용하지만, 중간 장비가 먼저 연결을 끊을 수 있다.  
   → 재사용할 때 요청에 실패하고, 재시도가 폭증할 수 있다.
   
3. **서버의 keepalive timeout이 너무 길고, 커넥션 풀이 과대**  
   → 연결 수 자체가 폭발할 수 있다.  
   → 서버는 연결 관리로 지치고, 처리량이 떨어진다.
   
4. **긴 스트리킹/대용량 요청인데 풀 관리가 서툰 경우**  
   → 요청 처리가 길어서 연결이 풀로 반환되지 않는다.  
   → 커넥션 풀 고갈발생  
   (또한 서버 입장에서는 FD가 고갈될 수 있다.)
   
5. **서버 보호가 필요한 경우**  
   → DDoS 공격 등에서 보호하기 위해 연결을 짧게 유지하는 것이 필요할 수 있다.

## 5 HTTPS 개요

## 6 TLS Handshake

## 7 HTTPS와 Keep-Alive의 관계
