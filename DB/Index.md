# Index(인덱스)
### 📚 목차
- [1 인덱스의 개념과 목적](#1-인덱스의-개념과-목적)
- [2 B-Tree / Hash 인덱스 구조](#2-b-tree--hash-인덱스-구조)
- [3 인덱스가 효율적인 경우 vs 비효율적인 경우](#3-인덱스가-효율적인-경우-vs-비효율적인-경우)
- [4 클러스터드 인덱스 / 논클러스터드 인덱스](#4-클러스터드-인덱스--논클러스터드-인덱스)
- [5 Composite Index(복합 인덱스) 순서 중요성](#5-composite-index복합-인덱스-순서-중요성)
- [6 커버링 인덱스, 인덱스 스캔 vs 풀 스캔](#6-커버링-인덱스-인덱스-스캔-vs-풀-스캔)
- [7 옵티마이저(Optimizer)](#7-옵티마이저optimizer)

## 1 인덱스의 개념과 목적
### 1.1 인덱스란 무엇인가?
> 인덱스는 "테이블 데이터를 빠르게 찾기 위해 만든, 정렬된 별도의 자료 구조(보통 B-Tree)이다.

원래 테이블은 행의 집합이고, 이것들은 순서대로 저장되어 있다.  
→ 인덱스틑 이 데이터들 중 **특정 칼럼에 대한 값과 그 포인터를 모아서 정렬된 구조를 따로 저장해 둔 것**이다.  
→ 어떤 컬럼을 기준으로 어떤 값이 있는 행을 빠르게 찾을 수 있다.

### 1.2 인덱스의 기본 원리 (정렬 기반 탐색)
1. 정렬된 상태를 유지
2. 그 위에서 "이분 탐색 + 트리 탐색" 방식으로 찾는다.

⇒ **조건 검색과 범위 검색**이 훨씬 빨라진다.

### 1.3 인덱스와 테이블의 관계 (데이터와 별도 저장)
> 인덱스는 테이블과 별도의 공간에 저장된다.

⇒ 테이블에 행을 INSERT/UPDATE/DELETE하면, 테이블 데이터 뿐만 아니라 **관련된 모든 인덱스 구조도 같이 수정**된다.

### 1.4 인덱스의 장점
사실상 **"읽기 성능 향상"** 이 전부다.  

- 조건 검색 속도 향상
- 졍렬/범위 조회에 유리
- 조인 성능 향상 (조인 조건에 인덱스가 있는 경우)
- 유니크 보장 (UNIQUE 인덱스를 쓰면 같은 값이 두 번 들어오지 않도록 DB가 자동으로 체크한다.)

### 1.5 인덱스의 단점
- **쓰기 비용 증가**  
  테이블에 데이터가 추가/수정/삭제될 때, 인덱스가 걸려있는 컬럼에 대한 인덱스 데이터도 변경해야 한다.

- **추가적인 디스크/메모리 사용**  
  인덱스도 데이터 구조 → 디스크 공간 차지
  자주 쓰는 인덱스 페이지는 버퍼 캐시에도 올라감 → 메모리 차지

- **잘못된 인덱스 설계로 인한 성능 악화**  
  카디널리티가 낮은 컬럼(ex. 성별) 같은 경우 인덱스 효과가 거의 없다.
  → 인덱스로 많은 컬럼을 필터링 하지 못해서 옵티마이저가 **여러 필드에 대해 랜덤 접근**하게 되고, 오히려 성능이 떨어질 수 있다.
  → 오히려 순차 접근이 prefetch 등으로 최적화가 가능함

  - **오히려 느려지는 이유**  
    index tree 검색으로 인한 비용  
    추가로 row pointer를 따라가며 테이블 데이터에 순차적으로 접근하는 것이 아닌 **랜덤하게 접근**  
    → **대량의 row를 랜덤 접근**  
    → 당연히 순차 접근보다 느려질 수 있다.

### 1.6 인덱스의 종류
- **구조 기준**  
  B-Tree 인덱스 vs Hash 인덱스
  
- **역할/정렬 기준**  
  클러스터드 인덱스 vs 논클러스터드 인덱스

- **구성 컬럼 개수 기준**  
  단일 컬럼 인덱스 vs 복합(Composite) 인덱스

- **제약 조건 연관**  
  PRIMARY KEY 인덱스 / UNIQUE 인덱스 / 일반(Non-Unique) 인덱스

## 2 B-Tree / Hash 인덱스 구조
### 2.1 B-Tree 인덱스 (DB 인덱스에서는 거의 항상 B+Tree를 사용함)
> B-Tree 계열은 **균형 트리**로, **각 노드가 다수의 키와 자식을 가지며**, 트리의 높이가 낮다.  
> 루트부터 리프까지의 깊이가 거의 일정하게 유지되도록 밸런싱된다.

- **주요 특징**
  
  - 정렬성
    
  - 왼쪽(prefix)부터 사용 (복합 인덱스의 경우)
    
  - 랜덤 I/O vs 순차 I/O  
    B-Tree 계열 → 필요한 페이지에 대해서만 랜덤 I/O  
    풀 스캔 → 전체 페이지를 순차 I/O

- **B-Tree와 B+Tree의 차이점**  
  <img width="1024" height="300" alt="image" src="https://github.com/user-attachments/assets/10dd010e-dadc-4dd3-b9b0-4d3a340f778c" />
  <img width="1125" height="383" alt="image" src="https://github.com/user-attachments/assets/35048d53-32fe-4926-ac49-52d1c6dc39dd" />
  - B-Tree는 내부 노드에도 value가 저장되지만, B+Tree는 내부 노드는 key만 저장하고, 리프노드에만 value를 저장한다.
    
  - B-Tree는 리프노드끼리 연결되어 있지 않지만, B+Tree는 리프 노드끼리 연결되어 있다.
    
  - B-Tree는 트리 전체에서 각 key가 한 번만 등장하지만, B+Tree의 내부 노드의 key는 리프 노드의 key를 복제한 것이기 때문에 중복된다.  
  → B+Tree에서 내부 노드는 원하는 리프노드를 찾기 위한 갈림길일 뿐이다.
  - B-Tree는 조회 중간에 찾는 값을 찾으면 바로 value가 있어서 반환이 가능하다.
    
  - B+Tree는 리프 노드가 연결되어 있어서 Range Scan이 매우 빠르다.

### 2.2 Hash 인덱스
> 키를 해시 함수에 넣어서 나온 값으로 버킷을 찾는 구조

**해시 함수 → `h(key) = bucket 번호`**

- **충돌 처리 방식**  

  - **체이닝**  
    충돌이 발생하면 버킷에 연결 리스트나 다른 구조로 key들을 모아둔다.  
    → 충돌에 매우 강함. 삭제가 쉬움.  
    → 실제로 사용하는 경우가 많음.  
    → load factor(테이블이 차 있는 정도)가 1이 넘어도 가능하다.  
    → worst-case의 경우 모든 key가 하나의 bucket에 들어갈 수 있다.  
    (LinkedList를 주로 사용하고, Java의 HashMap의 경우 RB-Tree를 사용한다.)

  - **Open Addressing(개방 주소법)**  
    충돌이 나면 해시 테이블 내부에서 다른 위치를 찾아서 저장하는 방식.  
    → 여러 방식이 있지만, 이중 해싱(Double Hashing) 방식으로 해시 함수를 한 번 더 씌우는 방식이 있다.  
    → 빈 공간을 찾을 때까지 규칙에 따라 다음 버킷으로 탐색한다.

  - **load factor란?**  
    저장된 키 개수를 총 버킷 수로 나눈 것(`저장된 키 개수 / 총 버킷 개수`)으로, Hash Table 기반 구조에서 주로 쓰인다.  
    체이닝 방식의 경우 load factor가 1이 넘을 수 있다.  
    반면 개방 주소법의 경우 load factor가 1에 가까워질수록 저장할 버킷을 찾기 힘들고, 1을 넘길 수 없다.

- **장점**  
  단일 조건에 의한 조회(동등 비교)에서 매우 빠르다.  
  키가 고르게 퍼져있으면 매우 효율적이다.

- **단점**  
  범위 검색 불가능  
  정렬을 지원하지 않음  
  충돌 관리 비용이 발생함

## 3 인덱스가 효율적인 경우 vs 비효율적인 경우
### 3.1 효율적인 경우
- 조건을 만족하는 행이 전체의 일부(1~5%)일 때

- PK, UNIQUE 조회 → 항상 한 건임

- 범위 조건을 사용하고 그 범위에 걸리는 데이터가 많지 않을 때

- 문자열 prefix 매칭 (`LIKE 'kim%'`)  
  → B-Tree 인덱스 계열인 경우 문자열로 정렬이 되어 빠르게 패턴 매칭 가능

- ORDER BY / GROUP BY

- 인덱스가 걸린 컬럼으로 JOIN 시

### 3.2 비효율적인 경우
- 너무 많은 행을 읽어야 할 때  
  → WHERE 조건 결과가 전체의 큰 비율(30% 이상)을 차지하는 경우

- 카디널리티가 극도록 낮은 컬럼 (성별, status 등)

- SQL 조건에 내장 함수를 씌워서 인덱스를 못 타는 경우

- 앞부분이 고정되지 않은 LIKE 패턴 (`LIKE '%kim'`)

- **타입이 안 맞거나 캐스팅**이 일어나는 경우

- 행 수가 적은 테이블의 경우

- 복합 인덱스인데 WHERE 조건에서 사용하는 순서가 안 맞는 경우

## 4 클러스터드 인덱스 / 논클러스터드 인덱스
### 4.1 클러스터드 인덱스(Clustered Index)
> 테이블 데이터 자체가 인덱스 순서에 맞게 정렬되어 저장되는 인덱스

- **핵심 개념**

  1. *테이블이 곧 인덱스*이다.  
     → B+Tree의 리프노드에 실제 row 전체가 들어가 있다.
     
  3. 물리 저장 순서 = 클러스터드 인덱스 순서  
     → 디스크에 row들이 PK 순서대로 저장된다.
     
- **특징**

  1. 한 테이블에 클러스터드 인덱스는 하나만 가능
     → **InnoDB에서는 PK가 곧 클러스터드 인덱스**이다.
     
  2. PK 기준 조회 / 범위 검색이 매우 빠름
     → 물리 구조 자체가 그렇게 저장된다.
     
  3. **PK가 순차적인 삽입일 때 매우 효율적**이지만, PK가 UUID같은 랜덤한 값이면 B+Tree 중간중간 끼어들어야 해서 추가적인 비용이 소모된다.

### 4.2 논클러스터드 인덱스(Non-clustred Index / Secondary Index)
> 테이블과 별도로 존재하는 인덱스  
> 인덱스 리프에서 '데이터 위치'를 한 번 더 타고 들어가야 함.

- **핵심 개념**

  InnoDB에서 보조 인덱스 **리프는 일반적으로 `(보조 인덱스 키, PK 값)`의 형태로 저장**된다.  
  → 트리에서 찾고, PK로 클러스터드 인덱스를 탐색  
  ⇒ **인덱스를 두 번 타는 구조**이다.  
  (쿼리에서 사용하는 컬럼들이 인덱스에 모두 포함되어 있으면, 논클러스터드 인덱스만으로 조회를 끝낼 수도 있다. 이를 커버링 인덱스라고 한다.)

- **단점**

  인덱스가 많을수록 테이블 데이터 삽입/수정/삭제 시에 추가적인 비용이 더 많이 발생한다.

⇒ MySQL의 InnoDB 기준으로는 *PK만 클러스터드 인덱스*이고, 나머지 인덱스는 전부 논클러스터드 인덱스이다.

## 5 Composite Index(복합 인덱스) 순서 중요성
### 두 개 이상의 컬럼으로 구성된 인덱스
> 복합 인덱스 = 두 개 이상 컬럼을 하나의 B-Tree 안에 정렬해 둔 인덱스

```SQL
CREATE INDEX idx_user_country_age
ON user (country, age);
```

### 인덱스 컬럼 순서의 중요성 - 왼쪽(prefix) 규칙
> B-Tree 복합 인덱스가 왼쪽에서부터 연속된 컬럼들만 제대로 쓸 수 있다.

`INDEX(a, b, c)`인 경우  
*가능한 경우* → `WHERE a = ?`, `WHERE a = ? AND b = ?`  
*제대로 못 쓰는 경우* → `WHERE b = ?`, `WHERE b = ? AND c = ?`  

→ 후자의 경우에는 옵티마이저가 아예 인덱스를 안 쓰고 풀 스캔을 선택할 수도 있다.

### 정렬(ORDER BY)과 복합 인덱스
**복합 인덱스는 WHERE과 ORDER BY를 같이 쓸 때 진짜 빛**이 난다.  

`INDEX(user_id, created_at)`인 경우  
→ `WHERE user_id = 100 ORDER BY created_at DESC`  
→ 인덱스 상에서 `user_id = 100`인 구간이 연속된 범위로 있고, 그 안에 `created_at` 순으로 정렬되어 있음  
→ 진짜 효과가 매우 크다.

### 인덱스 생성 시 컬럼 순서 결정 전략
1. "**쿼리 패턴**"부터 본다.
   어떤 쿼리가 실제로 자주 날라오는지 확인한다.

2. "**항상 붙는 조건**"을 앞에 둔다.

3. "**선택도가 높은 컬럼**"을 앞쪽에 두는 것을 고려한다.

4. `ORDER BY` / `GROUP BY`를 같이 고려한다.

5. 복합 인덱스를 너무 많이 만들지 않는다.  
   → 많이 만들면 삽입/수정/삭제 시에 성능이 떨어진다.  

⇒ 복합 인덱스는 적으면서 알차게 만들어야 한다.

## 6 커버링 인덱스, 인덱스 스캔 vs 풀 스캔
### 6.1 커버링 인덱스(Covering Index)
> 쿼리에 필요한 모든 컬럼을 **인덱스만 보고 해결**할 수 있는 인덱스

→ 인덱스의 리프 노드에 필요한 값이 다 있어서 2차로 PK로 탐색할 필요가 없음  
⇒ 이를 **커버링 인덱스 또는 Index Only Scan**이라고 한다.  
(실제 InnoDB는 MVCC visibility 체크를 위해 index only scan이 아니라 추가적인 조회를 할 수 있다.)  

```SQL
CREATE INDEX idx_orders_user_status_created
ON orders (user_id, status, created_at);
```
복합 인덱스를 위와 같이 구성한 경우에, 해당 필드에 대해서만 조건을 걸고,  
해당 필드에 대해서만 `SELECT`하는 쿼리를 날릴 경우에는 클러스터드 인덱스까지 조회하지 않는다.  
⇒ **쿼리가 요구하는 컬럼이 사용하는 인덱스에 모두 포함**되어 있어서 추가적인 클러스터드 인덱스 조회가 필요 없는 경우를 **커버링 인덱스**라고 한다.  

⇒ 그냥 **클러스터드 인덱스로 가지 않아도 되게 하는 최적화를 **커버링 인덱스**라고 함.  
(복합 인덱스가 아니어도 됨. 단일 인덱스여도 됨.)

- **커버링 인덱스 장점**  
  - 테이블 접근 불필요
 
  - 랜덤 I/O 감소
 
  - 옵티마이저가 우선적으로 고려함

- **커버링 인덱스 단점, 주의점**  
  - 인덱스가 너무 비대해짐  
    → 디스크/메모리 사용량, 업데이트 비용 모두 증가
  - 특정 쿼리 인덱스를 남발하면 오히려 튜닝 및 관리가 힘듦
 
  - **특정 읽기 위주**에서만 유리

### 6.2 인덱스 스캔 유형
- **Index Range Scan(인덱스 범위 스캔)**  
  > 인덱스 **일부 범위를 스캔**하는 가장 대표적인 방식

  `동등 비교`/`BETWEEN`/`대소 비교`/`문자열 prefix 조건`에서 사용됨.

- **Index Full Scan(인덱스 전체 스캔)**  
  > 인덱스의 **모든 리프 노드**를 처음부터 끝까지 스캔

  `WHERE 조건이 없는 경우`/`테이블 풀 스캔 보다는 인덱스 풀 스캔이 나은 경우`

- **Index Unique Scan(유니크 스캔)**  
  > UNIQUE 인덱스 또는 PK 인덱스에서 **정확히 하나의 값**을 찾는 스캔

  B+Tree에서 해당 키를 찾으면 그걸로 끝이다.

- **Index Only Scan(커버링 인덱스 스캔)**  
  > "커버링 인덱스" 상황에서, **테이블 접근 없이** 인덱스만 읽는 스캔

- **인덱스 후 테이블 접근 (Index Scan + Table Lookup)**  
  > 대부분의 일반적인 인덱스 사용 패턴

### 6.3 풀 테이블 스캔(Full Table Scan)과 비교
풀 스캔 → 테이블의 모든 row를 처음부터 끝까지 읽는 것.

## 7 옵티마이저(Optimizer)
### 7.1 옵티마이저의 역할
> 옵티마이저는 SQL을 가장 빠르게 실행할 수 있는 '**실행 계획**'을 선택하는 DB 엔진의 두뇌이다.

- **옵티마이저의 고민**  
  어떤 인덱스를 쓸 지
  어떤 조인 순서로 테이블을 합칠지
  조인 방식을 어떤 것을 쓸지
  ORDER BY를 인덱스로 처리? 정렬을 새로?
  GROUP BY를 해시로? 인덱스로?
  테이블 스캔 vs 인덱스 스캔
  ⇒ 이런 것의 **비용(cost)** 을 고려해서 가능한 모든 실행 계획들 중 **가장 낮은 비용의 계획을 선택**한다.

### 7.2 옵티마이저의 종류
- **Rule-based Optimizer (RBO, 규칙 기반)**  
  단순 규칙 기반으로 오래된 방식이다.  

  PK 있으면 PK 먼저, 인덱스가 있으면 항상 인덱스 사용 등, 현대 DB에서는 사용되지 않는다.

- **Cost-based Optimizer (CBO, 비용 기반)**  
  다음 정보를 사용해서 비용을 계산 후, 가장 낮은 비용의 계획을 선택한다.  

  `카디널리티`, `선택도`, `통계정보(값 분포, 데이터 크기 등)`,  
  `인덱스 깊이`, `랜덤 I/O vs 순차 I/O 비용 차이`,  
  `메모리에서 처리 가능 여부`

### 7.3 통계 정보의 중요성 (Statistics)
> 통계 정보는 DB가 다음을 알기 위해 수집하는 메타데이터이다.  
> (분포 히스토그램 / 최소,최댓값 / NULL 비율 / 카디널리티 / 전레 row 수 등)

- **통계 정보 최신화**  
  통계 정보가 최신화되지 않으면 인덱스 적용이 적절하게 되지 않을 수 있다.  

  → 개발자가 직접 최신화할 수도 있고, DB 엔진에서 자동으로 수행하기도 한다.
  → 주기적으로 실행해주는 것이 좋다.

### 7.4 실행 계획 요소
```SQL
explain select * from evaluation where restaurant_id = 510;
```
<img width="1978" height="317" alt="image" src="https://github.com/user-attachments/assets/9be2bfba-95e3-46bd-90e0-51568e06eb2b" />

- **type - 접근 방식**  
  (const / eq_ref, ref / range / index / ALL)

- **key - 사용한 인덱스**  

- **rows - 예상 row수**  
  → 통계 정보 기반으로 계산한 **예상되는 읽어야 하는 행 수**  
  → 높을 수록 성능이 좋지 않을 가능성이 높음

- **extra - 추가 정보**  
  Using index → 커버링 인덱스인 상황  
  Using where → where 조건으로 실제로 필터링 함  
  Using filesort → 정렬을 인덱스로 해결 못해서 파일 기반 정렬 수행 (비용 큼)  
  Using temporary → 임시 테이블을 생성함 (group by 등의 상황)

### 7.5 옵티마이저 힌트
> 옵티마이저가 잘못된 선택을 할 때, 개발자가 **직접 힌트를 줘서 "유도"할** 수 있다.

```SQL
SELECT /*+ INDEX(orders idx_orders_user_status_created) */
*
FROM orders
WHERE user_id = 10;
```
위는 특정 인덱스 사용을 권고하는 예시이다.

### 7.6 실제 성능 튜닝 순서
1. 느린 쿼리(상위 20%) 찾기
2. 실행 계획(Explain) 확인
3. 통계 정보 최신화 확인
4. 인덱스 설계 점검
5. 불필요한 인덱스 제거/정리
6. 조인 순서 / 서브쿼리 재장성 → 인덱스 활용 개선
7. 마지막 수단으로 힌트 사용
